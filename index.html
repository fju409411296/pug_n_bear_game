<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å‹•ç‰©è·‘é…·ãƒ»å°å°æˆ°é¬¥ | Animal Dash Fight</title>
    <style>
        /* --- CSS æ¨£å¼å€ --- */
        :root {
            --bg-color: #87CEEB; /* å¤©ç©ºè— */
            --ground-color: #8B4513; /* æ³¥åœŸè‰² */
            --grass-color: #32CD32; /* è‰åœ°è‰² */
            --ui-font: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #222;
            font-family: var(--ui-font);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none; /* ç¦æ­¢é¸å–æ–‡å­— */
        }

        #game-container {
            position: relative;
            width: 800px;
            height: 450px;
            background: var(--bg-color);
            border: 4px solid #fff;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI ä»‹é¢é€šç”¨è¨­å®š */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* è®“é»æ“Šç©¿é€åˆ° Canvas */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        /* HUD (æŠ¬é ­é¡¯ç¤ºå™¨) */
        #hud {
            justify-content: flex-start;
            align-items: flex-start;
            padding: 15px;
            box-sizing: border-box;
            flex-direction: row;
            justify-content: space-between;
        }

        .stat-group {
            display: flex;
            gap: 10px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .high-score-box {
            border: 2px solid #FFD700; /* é‡‘æ¡†ä»£è¡¨æœ€é«˜åˆ† */
            color: #FFD700;
        }

        /* éŠæˆ²é¸å–®èˆ‡çµæŸç•«é¢ */
        #start-screen, #game-over-screen {
            background: rgba(0, 0, 0, 0.8);
            pointer-events: auto; /* é€™è£¡éœ€è¦é»æ“Š */
            z-index: 10;
            backdrop-filter: blur(5px);
        }

        h1 {
            color: #FFD700;
            font-size: 48px;
            margin-bottom: 5px;
            text-shadow: 2px 2px 0 #000;
        }

        h2 {
            color: #fff;
            margin-bottom: 20px;
        }

        .best-score-display {
            color: #FFD700;
            font-size: 20px;
            margin-bottom: 30px;
            background: rgba(255, 215, 0, 0.1);
            padding: 5px 15px;
            border-radius: 15px;
            border: 1px solid #FFD700;
        }

        .btn-group {
            display: flex;
            gap: 20px;
        }

        button {
            background: #fff;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
            font-weight: bold;
            font-family: var(--ui-font);
        }

        button:hover {
            background: #f0f0f0;
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.95);
        }

        /* è§’è‰²é¸æ“‡å¡ç‰‡ */
        .char-card {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255,255,255,0.3);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: 0.3s;
            width: 120px;
        }

        .char-card:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: #FFD700;
            transform: translateY(-5px);
        }

        .char-icon { font-size: 50px; display: block; margin-bottom: 10px; }
        .char-name { color: #fff; font-size: 20px; font-weight: bold; display: block;}
        .char-stats { color: #ddd; font-size: 12px; margin-top: 5px; display: block; line-height: 1.5;}

        /* åº•éƒ¨æ“ä½œæç¤º */
        #controls-hint {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            pointer-events: none;
        }

        .key {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.4);
            margin: 0 3px;
        }

        /* éš±è—é¡åˆ¥ */
        .hidden { display: none !important; }

        /* æ–°ç´€éŒ„ç‰¹æ•ˆ */
        .new-record-anim {
            animation: blink 1s infinite;
            color: #FF4500;
        }
        @keyframes blink { 0% {opacity: 1;} 50% {opacity: 0.5;} 100% {opacity: 1;} }

    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="450"></canvas>

        <div id="hud" class="ui-layer hidden">
            <div class="stat-group">
                <div class="stat-box">â¤ï¸ <span id="hp-display">3</span></div>
                <div class="stat-box">ğŸª™ <span id="score-display">0</span></div>
            </div>
            <div class="stat-box high-score-box">ğŸ† <span id="hud-high-score">0</span></div>
        </div>

        <div id="start-screen" class="ui-layer">
            <h1>å‹•ç‰©è·‘é…·ãƒ»å°å°æˆ°é¬¥</h1>
            <div class="best-score-display">ğŸ† æœ€é«˜ç´€éŒ„: <span id="menu-high-score">0</span></div>
            <h2>è«‹é¸æ“‡ä½ çš„è‹±é›„</h2>
            <div class="btn-group">
                <div class="char-card" onclick="startGame('bear')">
                    <span class="char-icon">ğŸ»</span>
                    <span class="char-name">ç†Šç†Š</span>
                    <span class="char-stats">â¤ï¸ è¡€é‡é«˜<br>âš”ï¸ æ”»æ“Šå¼·</span>
                </div>
                <div class="char-card" onclick="startGame('pug')">
                    <span class="char-icon">ğŸ¶</span>
                    <span class="char-name">å·´å“¥</span>
                    <span class="char-stats">âš¡ é€Ÿåº¦å¿«<br>â« è·³å¾ˆé«˜</span>
                </div>
            </div>
        </div>

        <div id="game-over-screen" class="ui-layer hidden">
            <h1>GAME OVER</h1>
            <h2 id="final-score">å¾—åˆ†: 0</h2>
            <div id="new-record-msg" class="best-score-display hidden">ğŸŒŸ æ–°ç´€éŒ„ï¼ ğŸŒŸ</div>
            <button onclick="resetGame()">å†ç©ä¸€æ¬¡ â†º</button>
        </div>

        <div id="controls-hint">
            [<span class="key">ç©ºç™½éµ</span> è·³èº] &nbsp; 
            [<span class="key">â†“</span> æ»¾å‹•é–ƒé¿] &nbsp; 
            [<span class="key">â†’</span> æˆ– <span class="key">Z</span> æ”»æ“Š]
        </div>
    </div>

    <script>
        /* --- JS ç¨‹å¼é‚è¼¯å€ --- */
        
        // 1. éŠæˆ²è¨­å®šèˆ‡å¸¸æ•¸
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // éŠæˆ²ç‹€æ…‹åˆ—èˆ‰
        const STATE = { MENU: 0, PLAYING: 1, GAMEOVER: 2 };
        let currentState = STATE.MENU;

        // è§’è‰²è³‡æ–™åº« (ç†Šé€Ÿ4, å·´å“¥é€Ÿ6)
        const CHARACTERS = {
            bear:   { name: "ç†Š",   emoji: "ğŸ»", w: 50, h: 50, color: "#8B4513", speed: 4, jump: 13, hp: 5, attackRange: 60 },
            pug:    { name: "å·´å“¥", emoji: "ğŸ¶", w: 45, h: 45, color: "#F4A460", speed: 6, jump: 18, hp: 3, attackRange: 50 } 
        };

        // å…¨åŸŸè®Šæ•¸
        let gameFrame = 0;
        let score = 0;
        let highScore = localStorage.getItem('animalDashHS') || 0; // è®€å–æœ€é«˜åˆ†
        let gameSpeed = 5;
        let selectedCharKey = 'bear';
        let obstacles = [];
        let particles = []; 
        
        // è¼¸å…¥ç‹€æ…‹
        const keys = {
            jump: false,
            roll: false,
            attack: false
        };

        // 2. é¡åˆ¥å®šç¾©

        // --- ç©å®¶é¡åˆ¥ ---
        class Player {
            constructor(charKey) {
                const stats = CHARACTERS[charKey];
                this.w = stats.w;
                this.h = stats.h;
                this.originalH = stats.h; 
                this.x = 100;
                this.y = canvas.height - 100 - this.h;
                this.vy = 0;
                this.weight = 0.8; // é‡åŠ›
                this.jumpPower = stats.jump;
                this.maxHp = stats.hp;
                this.hp = stats.hp;
                this.emoji = stats.emoji;
                this.attackRange = stats.attackRange;
                
                this.groundY = canvas.height - 100; // åœ°é¢ä½ç½®
                this.onGround = true;
                
                // å‹•ä½œç‹€æ…‹
                this.isRolling = false;
                this.isAttacking = false;
                this.attackTimer = 0;
                this.invincible = false; // å—å‚·ç„¡æ•µæ™‚é–“
                this.invincibleTimer = 0;
            }

            update() {
                // è·³èºç‰©ç†
                if (keys.jump && this.onGround) {
                    this.vy = -this.jumpPower;
                    this.onGround = false;
                }
                
                this.y += this.vy;

                if (!this.onGround) {
                    this.vy += this.weight; 
                } else {
                    this.vy = 0;
                }

                // åœ°é¢ç¢°æ’ä¿®æ­£
                if (this.y > this.groundY - this.h) {
                    this.y = this.groundY - this.h;
                    this.onGround = true;
                }

                // æ»¾å‹•
                if (keys.roll && this.onGround) {
                    this.isRolling = true;
                    this.h = this.originalH / 2; 
                } else {
                    this.isRolling = false;
                    this.h = this.originalH;
                }

                // æ”»æ“Š
                if (keys.attack && !this.isAttacking && !this.isRolling) {
                    this.isAttacking = true;
                    this.attackTimer = 15; 
                    createEffect(this.x + this.w, this.y + this.h/2, 'SWISH');
                }

                if (this.isAttacking) {
                    this.attackTimer--;
                    if (this.attackTimer <= 0) {
                        this.isAttacking = false;
                    }
                }

                // ç„¡æ•µæ™‚é–“
                if (this.invincible) {
                    this.invincibleTimer--;
                    if (this.invincibleTimer <= 0) this.invincible = false;
                }
            }

            draw() {
                // ç„¡æ•µé–ƒçˆ
                if (this.invincible && gameFrame % 10 < 5) return;

                ctx.save();
                ctx.font = `${this.originalH}px Arial`;
                
                let drawX = this.x;
                if (this.isAttacking) drawX += 10;

                let drawY = this.y + (this.originalH - 10); 
                if(this.isRolling) drawY += 10;

                ctx.fillText(this.emoji, drawX, drawY);

                // æ”»æ“Šç¯„åœæç¤º
                if (this.isAttacking) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                    ctx.fillRect(this.x + this.w, this.y, this.attackRange, this.h);
                }
                ctx.restore();
            }

            getHitbox() {
                return { x: this.x + 10, y: this.y + 5, w: this.w - 20, h: this.h - 10 };
            }

            getAttackBox() {
                if (!this.isAttacking) return null;
                return { x: this.x + this.w, y: this.y, w: this.attackRange, h: this.h };
            }
        }

        // --- éšœç¤™ç‰© ---
        class Obstacle {
            constructor() {
                this.x = canvas.width;
                // éš¨æ©Ÿé¡å‹
                const rand = Math.random();
                
                if (rand < 0.3) {
                    this.type = 'stone';
                    this.w = 40; this.h = 40;
                    this.y = canvas.height - 100 - this.h;
                    this.emoji = 'ğŸª¨';
                    this.canKill = false; 
                } else if (rand < 0.6) {
                    this.type = 'bird';
                    this.w = 40; this.h = 40;
                    this.y = canvas.height - 100 - this.h - 60; // ç©ºä¸­
                    this.emoji = 'ğŸ¦…';
                    this.canKill = true;
                } else {
                    this.type = 'slime';
                    this.w = 45; this.h = 45;
                    this.y = canvas.height - 100 - this.h;
                    this.emoji = 'ğŸ‘¾';
                    this.canKill = true;
                }
                
                this.markedForDeletion = false;
            }

            update() {
                this.x -= gameSpeed;
                if (this.x < -this.w) this.markedForDeletion = true;
            }

            draw() {
                ctx.font = '40px Arial';
                ctx.fillText(this.emoji, this.x, this.y + 40);
            }
        }

        // --- é‡‘å¹£ ---
        class Coin {
            constructor() {
                this.w = 30; this.h = 30;
                this.x = canvas.width;
                this.y = canvas.height - 100 - 150 - Math.random() * 50; 
                this.emoji = 'ğŸª™';
                this.markedForDeletion = false;
            }
            update() {
                this.x -= gameSpeed;
                if (this.x < -this.w) this.markedForDeletion = true;
            }
            draw() {
                ctx.font = '30px Arial';
                ctx.fillText(this.emoji, this.x, this.y + 30);
            }
        }

        // --- ç‰¹æ•ˆ ---
        class Particle {
            constructor(x, y, type) {
                this.x = x; this.y = y;
                this.size = Math.random() * 10 + 5;
                this.speedX = Math.random() * 4 - 2;
                this.speedY = Math.random() * 4 - 2;
                this.color = type === 'HIT' ? 'orange' : 'white';
                this.life = 20;
                this.type = type; 
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.life--;
            }
            draw() {
                ctx.save();
                if (this.type === 'SWISH') {
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size + 10, 0, Math.PI * 2);
                    ctx.stroke();
                } else {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        let player;
        let coins = [];

        // 3. æ ¸å¿ƒåŠŸèƒ½å‡½æ•¸

        function init() {
            // æ›´æ–°ä¸»é¸å–®çš„æœ€é«˜åˆ†
            document.getElementById('menu-high-score').innerText = highScore;
            document.getElementById('hud-high-score').innerText = highScore;

            // ç¶å®šæŒ‰éµ
            window.addEventListener('keydown', e => {
                if (e.code === 'Space' || e.code === 'ArrowUp') keys.jump = true;
                if (e.code === 'ArrowDown') keys.roll = true;
                if (e.code === 'ArrowRight' || e.code === 'KeyZ') keys.attack = true;
            });

            window.addEventListener('keyup', e => {
                if (e.code === 'Space' || e.code === 'ArrowUp') keys.jump = false;
                if (e.code === 'ArrowDown') keys.roll = false;
                if (e.code === 'ArrowRight' || e.code === 'KeyZ') keys.attack = false;
            });
        }

        function startGame(charKey) {
            selectedCharKey = charKey;
            player = new Player(selectedCharKey);
            obstacles = [];
            coins = [];
            particles = [];
            score = 0;
            gameFrame = 0;
            gameSpeed = CHARACTERS[charKey].speed;
            
            currentState = STATE.PLAYING;
            
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            updateUI();
            
            animate();
        }

        function resetGame() {
            // å›åˆ°ä¸»ç•«é¢æ™‚æ›´æ–°æœ€é«˜åˆ†é¡¯ç¤º
            document.getElementById('menu-high-score').innerText = highScore;
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('start-screen').classList.remove('hidden');
            currentState = STATE.MENU;
        }

        function updateUI() {
            document.getElementById('hp-display').innerText = player.hp;
            document.getElementById('score-display').innerText = score;
        }

        function createEffect(x, y, type) {
            for(let i=0; i<5; i++){
                particles.push(new Particle(x, y, type));
            }
        }

        function checkCollision(rect1, rect2) {
            return (
                rect1.x < rect2.x + rect2.w &&
                rect1.x + rect1.w > rect2.x &&
                rect1.y < rect2.y + rect2.h &&
                rect1.y + rect1.h > rect2.y
            );
        }

        function gameOver() {
            currentState = STATE.GAMEOVER;
            
            // æª¢æŸ¥æ˜¯å¦æ‰“ç ´ç´€éŒ„
            let isNewRecord = false;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('animalDashHS', highScore); // å­˜å…¥ LocalStorage
                isNewRecord = true;
            }
            
            // æ›´æ–°çµç®—ç•«é¢
            document.getElementById('final-score').innerText = "å¾—åˆ†: " + score;
            
            const newRecordMsg = document.getElementById('new-record-msg');
            if (isNewRecord) {
                newRecordMsg.classList.remove('hidden');
                newRecordMsg.classList.add('new-record-anim');
            } else {
                newRecordMsg.classList.add('hidden');
                newRecordMsg.classList.remove('new-record-anim');
            }

            document.getElementById('hud').classList.add('hidden');
            document.getElementById('game-over-screen').classList.remove('hidden');
        }

        function handleCollisions() {
            const playerHitbox = player.getHitbox();
            const attackBox = player.getAttackBox();

            // 1. éšœç¤™ç‰©
            obstacles.forEach(obs => {
                if (obs.canKill && attackBox && checkCollision(attackBox, obs)) {
                    obs.markedForDeletion = true;
                    score += 10;
                    createEffect(obs.x + obs.w/2, obs.y + obs.h/2, 'HIT');
                }
                else if (!player.invincible && checkCollision(playerHitbox, obs)) {
                    player.hp--;
                    player.invincible = true;
                    player.invincibleTimer = 60; 
                    updateUI();
                    createEffect(player.x, player.y, 'HIT');
                    
                    if (player.hp <= 0) {
                        gameOver();
                    }
                }
            });

            // 2. é‡‘å¹£
            coins.forEach(coin => {
                let coinBox = { x: coin.x, y: coin.y, w: coin.w, h: coin.h };
                if (checkCollision(playerHitbox, coinBox)) {
                    coin.markedForDeletion = true;
                    score += 5;
                    updateUI();
                }
            });
        }

        function drawBackground() {
            ctx.fillStyle = '#87CEEB'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            let cloudX = (gameFrame * 0.5) % canvas.width;
            ctx.font = '80px Arial';
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.fillText('â˜ï¸', 100 - cloudX, 100);
            ctx.fillText('â˜ï¸', 600 - cloudX, 150);
            ctx.fillText('â˜ï¸', 900 - cloudX, 80);

            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, canvas.height - 100, canvas.width, 100);
            
            ctx.fillStyle = '#32CD32'; 
            ctx.fillRect(0, canvas.height - 100, canvas.width, 20);
            
            let grassOffset = (gameFrame * gameSpeed) % 50;
            for(let i = -1; i < canvas.width / 50 + 1; i++) {
                ctx.fillText('ğŸŒ±', i * 50 - grassOffset, canvas.height - 85);
            }
        }

        // 4. ä¸»éŠæˆ²è¿´åœˆ
        function animate() {
            if (currentState !== STATE.PLAYING) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            gameFrame++;
            
            // é›£åº¦éš¨æ™‚é–“å¢åŠ 
            if (gameFrame % 600 === 0) gameSpeed += 0.2;

            drawBackground();

            // ç”Ÿæˆ
            if (gameFrame % 100 === 0) obstacles.push(new Obstacle());
            if (gameFrame % 130 === 0) coins.push(new Coin());

            // æ›´æ–°èˆ‡ç¹ªè£½
            [...coins, ...obstacles].forEach(obj => {
                obj.update();
                obj.draw();
            });

            player.update();
            player.draw();
            
            particles.forEach((p, index) => {
                p.update();
                p.draw();
                if (p.life <= 0) particles.splice(index, 1);
            });

            obstacles = obstacles.filter(obj => !obj.markedForDeletion);
            coins = coins.filter(obj => !obj.markedForDeletion);

            handleCollisions();

            requestAnimationFrame(animate);
        }

        // åˆå§‹åŒ–
        init();

    </script>
</body>
</html>